{"version":3,"sources":["_psv/core.js"],"names":["define","THREE","PhotoSphereViewer","doT","PSVError","PSVUtils","PSVAnimation","PSVHUD","PSVLoader","PSVNavBar","PSVNotification","PSVOverlay","PSVPanel","PSVTooltip","prototype","_construct","options","SYSTEM","loaded","_loadSystem","this","config","clone","DEFAULTS","deepmerge","container","isCanvasSupported","isWebGLSupported","longitude_range","length","console","warn","latitude_range","undefined","tilt_up_max","tilt_down_max","Math","PI","HalfPI","max_fov","min_fov","temp_fov","cache_texture","isInteger","sphere_correction","roll","panorama_roll","keyboard","bound","default_fov","anim_lat","default_lat","parseAngle","map","angle","anim_speed","parseSpeed","caption","navbar","fisheye","parent","document","getElementById","loader","hud","panel","tooltip","notification","overlay","canvas_container","renderer","stereoEffect","noSleep","scene","camera","mesh","raycaster","doControls","prop","needsUpdate","isCubemap","position","longitude","latitude","ready","direction","zoom_lvl","vFov","hFov","aspect","move_speed","moving","zooming","start_mouse_x","start_mouse_y","mouse_x","mouse_y","mouse_history","gyro_alpha_offset","pinch_dist","main_reqid","orientation_cb","autorotate_cb","animation_promise","loading_promise","start_timeout","dblclick_data","dblclick_timeout","cache","size","width","height","pano_data","full_width","full_height","cropped_width","cropped_height","cropped_x","cropped_y","Object","keys","TEMPLATES","forEach","tpl","templates","template","photoSphereViewer","createElement","classList","add","appendChild","_setViewerSize","_onResize","tempZoom","default_zoom_lvl","degToRad","pixelRatio","hide","_bindEvents","panorama","setPanorama","one","show","markers","marker","addMarker","renderMarkers","time_anim","window","setTimeout","startAutorotate","bind","_run","trigger","touchEnabled","then","enabled","timestamp","Date","_render","requestAnimationFrame","sphericalCoordsToVector3","set","lookAt","copy","multiplyScalar","negate","fov","updateProjectionMatrix","render","_loadXMP","usexmpdata","Promise","resolve","progress","xhr","XMLHttpRequest","with_credentials","withCredentials","onreadystatechange","readyState","status","textContent","setProgress","binary","responseText","a","indexOf","b","data","substring","parseInt","getXMPValue","onprogress","e","lengthComputable","new_progress","total","onerror","reject","open","send","_loadTexture","tempPanorama","Array","isArray","i","CUBE_MAP","CUBE_HASHMAP","every","side","_loadCubemapTexture","_loadEquirectangularTexture","getPanoramaCache","image","ImageLoader","setCrossOrigin","load","img","texture","ratio","min","maxTextureWidth","resized_pano_data","buffer","getContext","drawImage","Texture","minFilter","LinearFilter","generateMipmaps","_putPanoramaCache","done","onload","sum","_setTexture","_createScene","material","dispose","Raycaster","WebGLRenderer","setSize","setPixelRatio","PerspectiveCamera","SPHERE_RADIUS","Scene","_createCubemap","_createSphere","className","domElement","scale","geometry","SphereGeometry","SPHERE_VERTICES","MeshBasicMaterial","DoubleSide","Mesh","x","_setSphereCorrection","cleanSphereCorrection","rotation","tilt","pan","BoxGeometry","CUBE_VERTICES","materials","push","BackSide","_transition","positionProvided","isExtendedPosition","zoomProvided","zoom","transparent","opacity","cleanPosition","verticalAxis","Vector3","rotateOnWorldAxis","horizontalAxis","cross","getWorldDirection","normalize","properties","start","end","duration","transition","easing","onTick","remove","rotate","_reverseAutorotate","self","newSpeed","range","speed","existingCache","slice","unshift","_stopAll","stopAutorotate","stopAnimation","stopGyroscopeControl","stopStereoView"],"mappings":"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","file":"../../_psv/core.js","sourcesContent":["define([\n  \"skylark-threejs\",\n  \"./ctoc\",\n  \"../doT\",\n  \"../PSVError\",\n  \"../PSVUtils\",\n  \"../PSVAnimation\",\n  \"../components/PSVHUD\",\n  \"../components/PSVLoader\",\n  \"../components/PSVNavBar\",\n  \"../components/PSVNotification\",\n  \"../components/PSVOverlay\",\n  \"../components/PSVPanel\",\n  \"../components/PSVTooltip\"\n],function(\n  THREE,\n  PhotoSphereViewer,\n  doT,\n  PSVError,\n  PSVUtils,\n  PSVAnimation,\n  PSVHUD,\n  PSVLoader,\n  PSVNavBar,\n  PSVNotification,\n  PSVOverlay,\n  PSVPanel,\n  PSVTooltip\n){\n  \"use strict\";\n\n  PhotoSphereViewer.prototype._construct = function (options) {\n\n    // init global system variables\n    if (!PhotoSphereViewer.SYSTEM.loaded) {\n      PhotoSphereViewer._loadSystem();\n    }\n\n    /**\n     * @summary Configuration object\n     * @member {Object}\n     * @readonly\n     */\n    this.config = PSVUtils.clone(PhotoSphereViewer.DEFAULTS);\n    PSVUtils.deepmerge(this.config, options);\n\n    // check container\n    if (!options.container) {\n      throw new PSVError('No value given for container.');\n    }\n\n    // must support canvas\n    if (!PhotoSphereViewer.SYSTEM.isCanvasSupported) {\n      throw new PSVError('Canvas is not supported.');\n    }\n\n    // must support webgl\n    if (!PhotoSphereViewer.SYSTEM.isWebGLSupported) {\n      throw new PSVError('WebGL is not supported.');\n    }\n\n    // longitude range must have two values\n    if (this.config.longitude_range && this.config.longitude_range.length !== 2) {\n      this.config.longitude_range = null;\n      console.warn('PhotoSphereViewer: longitude_range must have exactly two elements.');\n    }\n\n    if (this.config.latitude_range) {\n      // latitude range must have two values\n      if (this.config.latitude_range.length !== 2) {\n        this.config.latitude_range = null;\n        console.warn('PhotoSphereViewer: latitude_range must have exactly two elements.');\n      }\n      // latitude range must be ordered\n      else if (this.config.latitude_range[0] > this.config.latitude_range[1]) {\n        this.config.latitude_range = [this.config.latitude_range[1], this.config.latitude_range[0]];\n        console.warn('PhotoSphereViewer: latitude_range values must be ordered.');\n      }\n    }\n    // migrate legacy tilt_up_max and tilt_down_max\n    else if (this.config.tilt_up_max !== undefined || this.config.tilt_down_max !== undefined) {\n      this.config.latitude_range = [\n        this.config.tilt_down_max !== undefined ? this.config.tilt_down_max - Math.PI / 4 : -PSVUtils.HalfPI,\n        this.config.tilt_up_max !== undefined ? this.config.tilt_up_max + Math.PI / 4 : PSVUtils.HalfPI\n      ];\n      console.warn('PhotoSphereViewer: tilt_up_max and tilt_down_max are deprecated, use latitude_range instead.');\n    }\n\n    // min_fov and max_fov must be ordered\n    if (this.config.max_fov < this.config.min_fov) {\n      var temp_fov = this.config.max_fov;\n      this.config.max_fov = this.config.min_fov;\n      this.config.min_fov = temp_fov;\n      console.warn('PhotoSphereViewer: max_fov cannot be lower than min_fov.');\n    }\n\n    // cache_texture must be a positive integer or false\n    if (this.config.cache_texture && (!PSVUtils.isInteger(this.config.cache_texture) || this.config.cache_texture < 0)) {\n      this.config.cache_texture = PhotoSphereViewer.DEFAULTS.cache_texture;\n      console.warn('PhotoSphereViewer: invalid value for cache_texture');\n    }\n\n    // panorama_roll is deprecated\n    if ('panorama_roll' in this.config) {\n      this.config.sphere_correction.roll = this.config.panorama_roll;\n      console.warn('PhotoSphereViewer: panorama_roll is deprecated, use sphere_correction.roll instead');\n    }\n\n    // gyroscope is deprecated\n    if ('gyroscope' in this.config) {\n      console.warn('PhotoSphereViewer: gyroscope is deprecated, the control is automatically created if DeviceOrientationControls.js is loaded');\n    }\n\n    // keyboard=true becomes the default map\n    if (this.config.keyboard === true) {\n      this.config.keyboard = PSVUtils.clone(PhotoSphereViewer.DEFAULTS.keyboard);\n    }\n\n    // min_fov/max_fov between 1 and 179\n    this.config.min_fov = PSVUtils.bound(this.config.min_fov, 1, 179);\n    this.config.max_fov = PSVUtils.bound(this.config.max_fov, 1, 179);\n\n    // default default_fov is middle point between min_fov and max_fov\n    if (this.config.default_fov === null) {\n      this.config.default_fov = this.config.max_fov / 2 + this.config.min_fov / 2;\n    }\n    // default_fov between min_fov and max_fov\n    else {\n      this.config.default_fov = PSVUtils.bound(this.config.default_fov, this.config.min_fov, this.config.max_fov);\n    }\n\n    // default anim_lat is default_lat\n    if (this.config.anim_lat === null) {\n      this.config.anim_lat = this.config.default_lat;\n    }\n    // parse anim_lat, is between -PI/2 and PI/2\n    else {\n      this.config.anim_lat = PSVUtils.parseAngle(this.config.anim_lat, true);\n    }\n\n    // parse longitude_range, between 0 and 2*PI\n    if (this.config.longitude_range) {\n      this.config.longitude_range = this.config.longitude_range.map(function(angle) {\n        return PSVUtils.parseAngle(angle);\n      });\n    }\n\n    // parse latitude_range, between -PI/2 and PI/2\n    if (this.config.latitude_range) {\n      this.config.latitude_range = this.config.latitude_range.map(function(angle) {\n        return PSVUtils.parseAngle(angle, true);\n      });\n    }\n\n    // parse anim_speed\n    this.config.anim_speed = PSVUtils.parseSpeed(this.config.anim_speed);\n\n    // reactivate the navbar if the caption is provided\n    if (this.config.caption && !this.config.navbar) {\n      this.config.navbar = ['caption'];\n    }\n\n    // translate boolean fisheye to amount\n    if (this.config.fisheye === true) {\n      this.config.fisheye = 1;\n    }\n    else if (this.config.fisheye === false) {\n      this.config.fisheye = 0;\n    }\n\n    /**\n     * @summary Top most parent\n     * @member {HTMLElement}\n     * @readonly\n     */\n    this.parent = (typeof options.container === 'string') ? document.getElementById(options.container) : options.container;\n\n    /**\n     * @summary Main container\n     * @member {HTMLElement}\n     * @readonly\n     */\n    this.container = null;\n\n    /**\n     * @member {module:components.PSVLoader}\n     * @readonly\n     */\n    this.loader = null;\n\n    /**\n     * @member {module:components.PSVNavBar}\n     * @readonly\n     */\n    this.navbar = null;\n\n    /**\n     * @member {module:components.PSVHUD}\n     * @readonly\n     */\n    this.hud = null;\n\n    /**\n     * @member {module:components.PSVPanel}\n     * @readonly\n     */\n    this.panel = null;\n\n    /**\n     * @member {module:components.PSVTooltip}\n     * @readonly\n     */\n    this.tooltip = null;\n\n    /**\n     * @member {module:components.PSVNotification}\n     * @readonly\n     */\n    this.notification = null;\n\n    /**\n     * @member {module:components.PSVOverlay}\n     * @readonly\n     */\n    this.overlay = null;\n\n    /**\n     * @member {HTMLElement}\n     * @readonly\n     * @private\n     */\n    this.canvas_container = null;\n\n    /**\n     * @member {THREE.WebGLRenderer | THREE.CanvasRenderer}\n     * @readonly\n     * @private\n     */\n    this.renderer = null;\n\n    /**\n     * @member {THREE.StereoEffect}\n     * @private\n     */\n    this.stereoEffect = null;\n\n    /**\n     * @member {NoSleep}\n     * @private\n     */\n    this.noSleep = null;\n\n    /**\n     * @member {THREE.Scene}\n     * @readonly\n     * @private\n     */\n    this.scene = null;\n\n    /**\n     * @member {THREE.PerspectiveCamera}\n     * @readonly\n     * @private\n     */\n    this.camera = null;\n\n    /**\n     * @member {THREE.Mesh}\n     * @readonly\n     * @private\n     */\n    this.mesh = null;\n\n    /**\n     * @member {THREE.Raycaster}\n     * @readonly\n     * @private\n     */\n    this.raycaster = null;\n\n    /**\n     * @member {THREE.DeviceOrientationControls}\n     * @readonly\n     * @private\n     */\n    this.doControls = null;\n\n    /**\n     * @summary Internal properties\n     * @member {Object}\n     * @readonly\n     * @property {boolean} needsUpdate - if the view needs to be renderer\n     * @property {boolean} isCubemap - if the panorama is a cubemap\n     * @property {PhotoSphereViewer.Position} position - current direction of the camera\n     * @property {THREE.Vector3} direction - direction of the camera\n     * @property {float} anim_speed - parsed animation speed (rad/sec)\n     * @property {int} zoom_lvl - current zoom level\n     * @property {float} vFov - vertical FOV\n     * @property {float} hFov - horizontal FOV\n     * @property {float} aspect - viewer aspect ratio\n     * @property {float} move_speed - move speed (computed with pixel ratio and configuration move_speed)\n     * @property {boolean} moving - is the user moving\n     * @property {boolean} zooming - is the user zooming\n     * @property {int} start_mouse_x - start x position of the click/touch\n     * @property {int} start_mouse_y - start y position of the click/touch\n     * @property {int} mouse_x - current x position of the cursor\n     * @property {int} mouse_y - current y position of the cursor\n     * @property {Array[]} mouse_history - list of latest positions of the cursor, [time, x, y]\n     * @property {int} gyro_alpha_offset - current alpha offset for gyroscope controls\n     * @property {int} pinch_dist - distance between fingers when zooming\n     * @property main_reqid - animationRequest id of the main event loop\n     * @property {function} orientation_cb - update callback of the device orientation\n     * @property {function} autorotate_cb - update callback of the automatic rotation\n     * @property {Promise} animation_promise - promise of the current animation (either go to position or image transition)\n     * @property {Promise} loading_promise - promise of the setPanorama method\n     * @property start_timeout - timeout id of the automatic rotation delay\n     * @property {PhotoSphereViewer.ClickData} dblclick_data - temporary storage of click data between two clicks\n     * @property dblclick_timeout - timeout id for double click\n     * @property {PhotoSphereViewer.CacheItem[]} cache - cached panoramas\n     * @property {PhotoSphereViewer.Size} size - size of the container\n     * @property {PhotoSphereViewer.PanoData} pano_data - panorama metadata\n     */\n    this.prop = {\n      needsUpdate: true,\n      isCubemap: undefined,\n      position: {\n        longitude: 0,\n        latitude: 0\n      },\n      ready: false,\n      direction: null,\n      anim_speed: 0,\n      zoom_lvl: 0,\n      vFov: 0,\n      hFov: 0,\n      aspect: 0,\n      move_speed: 0.1,\n      moving: false,\n      zooming: false,\n      start_mouse_x: 0,\n      start_mouse_y: 0,\n      mouse_x: 0,\n      mouse_y: 0,\n      mouse_history: [],\n      gyro_alpha_offset: 0,\n      pinch_dist: 0,\n      main_reqid: null,\n      orientation_cb: null,\n      autorotate_cb: null,\n      animation_promise: null,\n      loading_promise: null,\n      start_timeout: null,\n      dblclick_data: null,\n      dblclick_timeout: null,\n      cache: [],\n      size: {\n        width: 0,\n        height: 0\n      },\n      pano_data: {\n        full_width: 0,\n        full_height: 0,\n        cropped_width: 0,\n        cropped_height: 0,\n        cropped_x: 0,\n        cropped_y: 0\n      }\n    };\n\n    // init templates\n    Object.keys(PhotoSphereViewer.TEMPLATES).forEach(function(tpl) {\n      if (!this.config.templates[tpl]) {\n        this.config.templates[tpl] = PhotoSphereViewer.TEMPLATES[tpl];\n      }\n      if (typeof this.config.templates[tpl] === 'string') {\n        this.config.templates[tpl] = doT.template(this.config.templates[tpl]);\n      }\n    }, this);\n\n    // init\n    this.parent.photoSphereViewer = this;\n\n      // create actual container\n      this.container = document.createElement('div');\n      this.container.classList.add('psv-container');\n      this.parent.appendChild(this.container);\n\n      // apply container size\n      if (this.config.size !== null) {\n        this._setViewerSize(this.config.size);\n      }\n      this._onResize();\n\n      // apply default zoom level\n      var tempZoom = (this.config.default_fov - this.config.min_fov) / (this.config.max_fov - this.config.min_fov) * 100;\n      this.config.default_zoom_lvl = tempZoom - 2 * (tempZoom - 50);\n\n      // actual move speed depends on pixel-ratio\n      this.prop.move_speed = THREE.Math.degToRad(this.config.move_speed / PhotoSphereViewer.SYSTEM.pixelRatio);\n\n      // load loader (!!)\n      this.loader = new PSVLoader(this);\n      this.loader.hide();\n\n      // load navbar\n      this.navbar = new PSVNavBar(this);\n      this.navbar.hide();\n\n      // load hud\n      this.hud = new PSVHUD(this);\n      this.hud.hide();\n\n      // load side panel\n      this.panel = new PSVPanel(this);\n\n      // load hud tooltip\n      this.tooltip = new PSVTooltip(this.hud);\n\n      // load notification\n      this.notification = new PSVNotification(this);\n\n      // load overlay\n      this.overlay = new PSVOverlay(this);\n\n      // attach event handlers\n      this._bindEvents();\n\n      // load panorama\n      if (this.config.panorama) {\n        this.setPanorama(this.config.panorama);\n      }\n\n      // enable GUI after first render\n      this.one('render', function() {\n        if (this.config.navbar) {\n          this.container.classList.add('psv-container--has-navbar');\n          this.navbar.show();\n        }\n\n        this.hud.show();\n\n        if (this.config.markers) {\n          this.config.markers.forEach(function(marker) {\n            this.hud.addMarker(marker, false);\n          }, this);\n\n          this.hud.renderMarkers();\n        }\n\n        // Queue animation\n        if (this.config.time_anim !== false) {\n          this.prop.start_timeout = window.setTimeout(this.startAutorotate.bind(this), this.config.time_anim);\n        }\n\n        setTimeout(function() {\n          // start render loop\n          this._run();\n\n          /**\n           * @event ready\n           * @memberof PhotoSphereViewer\n           * @summary Triggered when the panorama image has been loaded and the viewer is ready to perform the first render\n           */\n          this.trigger('ready');\n        }.bind(this), 0);\n      }.bind(this));\n\n      PhotoSphereViewer.SYSTEM.touchEnabled.then(function(enabled) {\n        if (enabled) {\n          this.container.classList.add('psv-is-touch');\n        }\n      }.bind(this));\n  };\n\n\n\n  /**\n   * @summary Main event loop, calls {@link PhotoSphereViewer._render} if `prop.needsUpdate` is true\n   * @param {int} timestamp\n   * @fires PhotoSphereViewer.filter:before-render\n   * @private\n   */\n  PhotoSphereViewer.prototype._run = function(timestamp) {\n    /**\n     * @event before-render\n     * @memberof PhotoSphereViewer\n     * @summary Triggered before a render, used to modify the view\n     * @param {int} timestamp - time provided by requestAnimationFrame\n     */\n    this.trigger('before-render', timestamp || +new Date());\n\n    if (this.prop.needsUpdate) {\n      this._render();\n      this.prop.needsUpdate = false;\n    }\n\n    this.prop.main_reqid = window.requestAnimationFrame(this._run.bind(this));\n  };\n\n  /**\n   * @summary Performs a render\n   * @fires PhotoSphereViewer.render\n   * @private\n   */\n  PhotoSphereViewer.prototype._render = function() {\n    this.prop.direction = this.sphericalCoordsToVector3(this.prop.position);\n    this.camera.position.set(0, 0, 0);\n    this.camera.lookAt(this.prop.direction);\n\n    if (this.config.fisheye) {\n      this.camera.position.copy(this.prop.direction).multiplyScalar(this.config.fisheye / 2).negate();\n    }\n\n    this.camera.aspect = this.prop.aspect;\n    this.camera.fov = this.prop.vFov;\n    this.camera.updateProjectionMatrix();\n\n    (this.stereoEffect || this.renderer).render(this.scene, this.camera);\n\n    /**\n     * @event render\n     * @memberof PhotoSphereViewer\n     * @summary Triggered on each viewer render, **this event is triggered very often**\n     */\n    this.trigger('render');\n  };\n\n  /**\n   * @summary Loads the XMP data with AJAX\n   * @param {string} panorama\n   * @returns {Promise.<PhotoSphereViewer.PanoData>}\n   * @throws {PSVError} when the image cannot be loaded\n   * @private\n   */\n  PhotoSphereViewer.prototype._loadXMP = function(panorama) {\n    if (!this.config.usexmpdata) {\n      return Promise.resolve(null);\n    }\n\n    return new Promise(function(resolve) {\n      var progress = 0;\n\n      var xhr = new XMLHttpRequest();\n      if (this.config.with_credentials) {\n        xhr.withCredentials = true;\n      }\n\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200 || xhr.status === 201 || xhr.status === 202 || xhr.status === 0) {\n            this.loader.setProgress(100);\n\n            var binary = xhr.responseText;\n            var a = binary.indexOf('<x:xmpmeta'), b = binary.indexOf('</x:xmpmeta>');\n            var data = binary.substring(a, b);\n            var pano_data = null;\n\n            if (a !== -1 && b !== -1 && data.indexOf('GPano:') !== -1) {\n              pano_data = {\n                full_width: parseInt(PSVUtils.getXMPValue(data, 'FullPanoWidthPixels')),\n                full_height: parseInt(PSVUtils.getXMPValue(data, 'FullPanoHeightPixels')),\n                cropped_width: parseInt(PSVUtils.getXMPValue(data, 'CroppedAreaImageWidthPixels')),\n                cropped_height: parseInt(PSVUtils.getXMPValue(data, 'CroppedAreaImageHeightPixels')),\n                cropped_x: parseInt(PSVUtils.getXMPValue(data, 'CroppedAreaLeftPixels')),\n                cropped_y: parseInt(PSVUtils.getXMPValue(data, 'CroppedAreaTopPixels'))\n              };\n\n              if (!pano_data.full_width || !pano_data.full_height || !pano_data.cropped_width || !pano_data.cropped_height) {\n                console.warn('PhotoSphereViewer: invalid XMP data');\n                pano_data = null;\n              }\n            }\n\n            resolve(pano_data);\n          }\n          else {\n            this.container.textContent = 'Cannot load image';\n            throw new PSVError('Cannot load image');\n          }\n        }\n        else if (xhr.readyState === 3) {\n          this.loader.setProgress(progress += 10);\n        }\n      }.bind(this);\n\n      xhr.onprogress = function(e) {\n        if (e.lengthComputable) {\n          var new_progress = parseInt(e.loaded / e.total * 100);\n          if (new_progress > progress) {\n            progress = new_progress;\n            this.loader.setProgress(progress);\n          }\n        }\n      }.bind(this);\n\n      xhr.onerror = function(e) {\n        this.container.textContent = 'Cannot load image';\n        reject(e);\n        throw new PSVError('Cannot load image');\n      }.bind(this);\n\n      xhr.open('GET', panorama, true);\n      xhr.send(null);\n    }.bind(this));\n  };\n\n  /**\n   * @summary Loads the panorama texture(s)\n   * @param {string|string[]} panorama\n   * @returns {Promise.<THREE.Texture|THREE.Texture[]>}\n   * @fires PhotoSphereViewer.panorama-load-progress\n   * @throws {PSVError} when the image cannot be loaded\n   * @private\n   */\n  PhotoSphereViewer.prototype._loadTexture = function(panorama) {\n    var tempPanorama = [];\n\n    if (Array.isArray(panorama)) {\n      if (panorama.length !== 6) {\n        throw new PSVError('Must provide exactly 6 image paths when using cubemap.');\n      }\n\n      // reorder images\n      for (var i = 0; i < 6; i++) {\n        tempPanorama[i] = panorama[PhotoSphereViewer.CUBE_MAP[i]];\n      }\n      panorama = tempPanorama;\n    }\n    else if (typeof panorama === 'object') {\n      if (!PhotoSphereViewer.CUBE_HASHMAP.every(function(side) {\n          return !!panorama[side];\n        })) {\n        throw new PSVError('Must provide exactly left, front, right, back, top, bottom when using cubemap.');\n      }\n\n      // transform into array\n      PhotoSphereViewer.CUBE_HASHMAP.forEach(function(side, i) {\n        tempPanorama[i] = panorama[side];\n      });\n      panorama = tempPanorama;\n    }\n\n    if (Array.isArray(panorama)) {\n      if (this.prop.isCubemap === false) {\n        throw new PSVError('The viewer was initialized with an equirectangular panorama, cannot switch to cubemap.');\n      }\n\n      if (this.config.fisheye) {\n        console.warn('PhotoSphereViewer: fisheye effect with cubemap texture can generate distorsions.');\n      }\n\n      if (this.config.cache_texture === PhotoSphereViewer.DEFAULTS.cache_texture) {\n        this.config.cache_texture *= 6;\n      }\n\n      this.prop.isCubemap = true;\n\n      return this._loadCubemapTexture(panorama);\n    }\n    else {\n      if (this.prop.isCubemap === true) {\n        throw new PSVError('The viewer was initialized with an cubemap, cannot switch to equirectangular panorama.');\n      }\n\n      this.prop.isCubemap = false;\n\n      return this._loadEquirectangularTexture(panorama);\n    }\n  };\n\n  /**\n   * @summary Loads the sphere texture\n   * @param {string} panorama\n   * @returns {Promise.<THREE.Texture>}\n   * @fires PhotoSphereViewer.panorama-load-progress\n   * @throws {PSVError} when the image cannot be loaded\n   * @private\n   */\n  PhotoSphereViewer.prototype._loadEquirectangularTexture = function(panorama) {\n    if (this.config.cache_texture) {\n      var cache = this.getPanoramaCache(panorama);\n\n      if (cache) {\n        this.prop.pano_data = cache.pano_data;\n\n        return Promise.resolve(cache.image);\n      }\n    }\n\n    return this._loadXMP(panorama).then(function(pano_data) {\n      return new Promise(function(resolve, reject) {\n        var loader = new THREE.ImageLoader();\n        var progress = pano_data ? 100 : 0;\n\n        if (this.config.with_credentials) {\n          loader.setCrossOrigin('use-credentials');\n        }\n        else {\n          loader.setCrossOrigin('anonymous');\n        }\n\n        var onload = function(img) {\n          progress = 100;\n\n          this.loader.setProgress(progress);\n\n          /**\n           * @event panorama-load-progress\n           * @memberof PhotoSphereViewer\n           * @summary Triggered while a panorama image is loading\n           * @param {string} panorama\n           * @param {int} progress\n           */\n          this.trigger('panorama-load-progress', panorama, progress);\n\n          // Config XMP data\n          if (!pano_data && this.config.pano_data) {\n            pano_data = PSVUtils.clone(this.config.pano_data);\n          }\n\n          // Default XMP data\n          if (!pano_data) {\n            pano_data = {\n              full_width: img.width,\n              full_height: img.height,\n              cropped_width: img.width,\n              cropped_height: img.height,\n              cropped_x: 0,\n              cropped_y: 0\n            };\n          }\n\n          this.prop.pano_data = pano_data;\n\n          var texture;\n\n          var ratio = Math.min(pano_data.full_width, PhotoSphereViewer.SYSTEM.maxTextureWidth) / pano_data.full_width;\n\n          // resize image / fill cropped parts with black\n          if (ratio !== 1 || pano_data.cropped_width !== pano_data.full_width || pano_data.cropped_height !== pano_data.full_height) {\n            var resized_pano_data = PSVUtils.clone(pano_data);\n\n            resized_pano_data.full_width *= ratio;\n            resized_pano_data.full_height *= ratio;\n            resized_pano_data.cropped_width *= ratio;\n            resized_pano_data.cropped_height *= ratio;\n            resized_pano_data.cropped_x *= ratio;\n            resized_pano_data.cropped_y *= ratio;\n\n            img.width = resized_pano_data.cropped_width;\n            img.height = resized_pano_data.cropped_height;\n\n            var buffer = document.createElement('canvas');\n            buffer.width = resized_pano_data.full_width;\n            buffer.height = resized_pano_data.full_height;\n\n            var ctx = buffer.getContext('2d');\n            ctx.drawImage(img, resized_pano_data.cropped_x, resized_pano_data.cropped_y, resized_pano_data.cropped_width, resized_pano_data.cropped_height);\n\n            texture = new THREE.Texture(buffer);\n          }\n          else {\n            texture = new THREE.Texture(img);\n          }\n\n          texture.needsUpdate = true;\n          texture.minFilter = THREE.LinearFilter;\n          texture.generateMipmaps = false;\n\n          if (this.config.cache_texture) {\n            this._putPanoramaCache({\n              panorama: panorama,\n              image: texture,\n              pano_data: pano_data\n            });\n          }\n\n          resolve(texture);\n        };\n\n        var onprogress = function(e) {\n          if (e.lengthComputable) {\n            var new_progress = parseInt(e.loaded / e.total * 100);\n\n            if (new_progress > progress) {\n              progress = new_progress;\n              this.loader.setProgress(progress);\n              this.trigger('panorama-load-progress', panorama, progress);\n            }\n          }\n        };\n\n        var onerror = function(e) {\n          this.container.textContent = 'Cannot load image';\n          reject(e);\n          throw new PSVError('Cannot load image');\n        };\n\n        loader.load(panorama, onload.bind(this), onprogress.bind(this), onerror.bind(this));\n      }.bind(this));\n    }.bind(this));\n  };\n\n  /**\n   * @summary Load the six textures of the cube\n   * @param {string[]} panorama\n   * @returns {Promise.<THREE.Texture[]>}\n   * @fires PhotoSphereViewer.panorama-load-progress\n   * @throws {PSVError} when the image cannot be loaded\n   * @private\n   */\n  PhotoSphereViewer.prototype._loadCubemapTexture = function(panorama) {\n    return new Promise(function(resolve, reject) {\n      var loader = new THREE.ImageLoader();\n      var progress = [0, 0, 0, 0, 0, 0];\n      var loaded = [];\n      var done = 0;\n\n      if (this.config.with_credentials) {\n        loader.setCrossOrigin('use-credentials');\n      }\n      else {\n        loader.setCrossOrigin('anonymous');\n      }\n\n      var onend = function() {\n        loaded.forEach(function(img) {\n          img.needsUpdate = true;\n          img.minFilter = THREE.LinearFilter;\n          img.generateMipmaps = false;\n        });\n\n        resolve(loaded);\n      };\n\n      var onload = function(i, img) {\n        done++;\n        progress[i] = 100;\n\n        this.loader.setProgress(PSVUtils.sum(progress) / 6);\n        this.trigger('panorama-load-progress', panorama[i], progress[i]);\n\n        var ratio = Math.min(img.width, PhotoSphereViewer.SYSTEM.maxTextureWidth / 2) / img.width;\n\n        // resize image\n        if (ratio !== 1) {\n          var buffer = document.createElement('canvas');\n          buffer.width = img.width * ratio;\n          buffer.height = img.height * ratio;\n\n          var ctx = buffer.getContext('2d');\n          ctx.drawImage(img, 0, 0, buffer.width, buffer.height);\n\n          loaded[i] = new THREE.Texture(buffer);\n        }\n        else {\n          loaded[i] = new THREE.Texture(img);\n        }\n\n        if (this.config.cache_texture) {\n          this._putPanoramaCache({\n            panorama: panorama[i],\n            image: loaded[i]\n          });\n        }\n\n        if (done === 6) {\n          onend();\n        }\n      };\n\n      var onprogress = function(i, e) {\n        if (e.lengthComputable) {\n          var new_progress = parseInt(e.loaded / e.total * 100);\n\n          if (new_progress > progress[i]) {\n            progress[i] = new_progress;\n            this.loader.setProgress(PSVUtils.sum(progress) / 6);\n            this.trigger('panorama-load-progress', panorama[i], progress[i]);\n          }\n        }\n      };\n\n      var onerror = function(i, e) {\n        this.container.textContent = 'Cannot load image';\n        reject(e);\n        throw new PSVError('Cannot load image ' + i);\n      };\n\n      for (var i = 0; i < 6; i++) {\n        if (this.config.cache_texture) {\n          var cache = this.getPanoramaCache(panorama[i]);\n\n          if (cache) {\n            done++;\n            progress[i] = 100;\n            loaded[i] = cache.image;\n            continue;\n          }\n        }\n\n        loader.load(panorama[i], onload.bind(this, i), onprogress.bind(this, i), onerror.bind(this, i));\n      }\n\n      if (done === 6) {\n        resolve(loaded);\n      }\n    }.bind(this));\n  };\n\n  /**\n   * @summary Applies the texture to the scene, creates the scene if needed\n   * @param {THREE.Texture|THREE.Texture[]} texture\n   * @fires PhotoSphereViewer.panorama-loaded\n   * @private\n   */\n  PhotoSphereViewer.prototype._setTexture = function(texture) {\n    if (!this.scene) {\n      this._createScene();\n    }\n\n    if (this.prop.isCubemap) {\n      for (var i = 0; i < 6; i++) {\n        if (this.mesh.material[i].map) {\n          this.mesh.material[i].map.dispose();\n        }\n\n        this.mesh.material[i].map = texture[i];\n      }\n    }\n    else {\n      if (this.mesh.material.map) {\n        this.mesh.material.map.dispose();\n      }\n\n      this.mesh.material.map = texture;\n    }\n\n    /**\n     * @event panorama-loaded\n     * @memberof PhotoSphereViewer\n     * @summary Triggered when a panorama image has been loaded\n     */\n    this.trigger('panorama-loaded');\n\n    this._render();\n  };\n\n  /**\n   * @summary Creates the 3D scene and GUI components\n   * @private\n   */\n  PhotoSphereViewer.prototype._createScene = function() {\n    this.raycaster = new THREE.Raycaster();\n\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(this.prop.size.width, this.prop.size.height);\n    this.renderer.setPixelRatio(PhotoSphereViewer.SYSTEM.pixelRatio);\n\n    this.camera = new THREE.PerspectiveCamera(this.config.default_fov, this.prop.size.width / this.prop.size.height, 1,  3 * PhotoSphereViewer.SPHERE_RADIUS);\n    this.camera.position.set(0, 0, 0);\n\n    this.scene = new THREE.Scene();\n    this.scene.add(this.camera);\n\n    if (this.prop.isCubemap) {\n      this.mesh = this._createCubemap();\n    }\n    else {\n      this.mesh = this._createSphere();\n    }\n\n    this.scene.add(this.mesh);\n\n    // create canvas container\n    this.canvas_container = document.createElement('div');\n    this.canvas_container.className = 'psv-canvas-container';\n    this.renderer.domElement.className = 'psv-canvas';\n    this.container.appendChild(this.canvas_container);\n    this.canvas_container.appendChild(this.renderer.domElement);\n  };\n\n  /**\n   * @summary Creates the sphere mesh\n   * @param {number} [scale=1]\n   * @returns {THREE.Mesh}\n   * @private\n   */\n  PhotoSphereViewer.prototype._createSphere = function(scale) {\n    scale = scale || 1;\n\n    // The middle of the panorama is placed at longitude=0\n    var geometry = new THREE.SphereGeometry(\n      PhotoSphereViewer.SPHERE_RADIUS * scale,\n      PhotoSphereViewer.SPHERE_VERTICES,\n      PhotoSphereViewer.SPHERE_VERTICES,\n      -PSVUtils.HalfPI\n    );\n\n    var material = new THREE.MeshBasicMaterial({\n      side: THREE.DoubleSide, // needs to be DoubleSide for CanvasRenderer\n    });\n\n    var mesh = new THREE.Mesh(geometry, material);\n    mesh.scale.x = -1;\n\n    return mesh;\n  };\n\n  /**\n   * @summary Applies a SphereCorrection to a Mesh\n   * @param {THREE.Mesh} mesh\n   * @param {PhotoSphereViewer.SphereCorrection} sphere_correction\n   * @private\n   */\n  PhotoSphereViewer.prototype._setSphereCorrection = function(mesh, sphere_correction) {\n    this.cleanSphereCorrection(sphere_correction);\n    mesh.rotation.set(\n      sphere_correction.tilt,\n      sphere_correction.pan,\n      sphere_correction.roll\n    );\n  };\n\n  /**\n   * @summary Creates the cube mesh\n   * @param {number} [scale=1]\n   * @returns {THREE.Mesh}\n   * @private\n   */\n  PhotoSphereViewer.prototype._createCubemap = function(scale) {\n    scale = scale || 1;\n\n    var geometry = new THREE.BoxGeometry(\n      PhotoSphereViewer.SPHERE_RADIUS * 2 * scale, PhotoSphereViewer.SPHERE_RADIUS * 2 * scale, PhotoSphereViewer.SPHERE_RADIUS * 2 * scale,\n      PhotoSphereViewer.CUBE_VERTICES, PhotoSphereViewer.CUBE_VERTICES, PhotoSphereViewer.CUBE_VERTICES\n    );\n\n    var materials = [];\n    for (var i = 0; i < 6; i++) {\n      materials.push(new THREE.MeshBasicMaterial({\n        side: THREE.BackSide,\n      }));\n    }\n\n    var mesh = new THREE.Mesh(geometry, materials);\n    mesh.scale.set(1, 1, -1);\n\n    return mesh;\n  };\n\n  /**\n   * @summary Performs transition between the current and a new texture\n   * @param {THREE.Texture} texture\n   * @param {PhotoSphereViewer.PanoramaOptions} options\n   * @returns {Promise}\n   * @private\n   * @throws {PSVError} if the panorama is a cubemap\n   */\n  PhotoSphereViewer.prototype._transition = function(texture, options) {\n    var mesh;\n\n    var positionProvided = this.isExtendedPosition(options);\n    var zoomProvided = options.zoom !== undefined;\n\n    if (this.prop.isCubemap) {\n      if (positionProvided) {\n        console.warn('PhotoSphereViewer: cannot perform cubemap transition to different position.');\n        positionProvided = false;\n      }\n\n      mesh = this._createCubemap(0.9);\n\n      mesh.material.forEach(function(material, i) {\n        material.map = texture[i];\n        material.transparent = true;\n        material.opacity = 0;\n      });\n    }\n    else {\n      mesh = this._createSphere(0.9);\n\n      mesh.material.map = texture;\n      mesh.material.transparent = true;\n      mesh.material.opacity = 0;\n\n      if (options.sphere_correction) {\n        this._setSphereCorrection(mesh, options.sphere_correction);\n      }\n    }\n\n    // rotate the new sphere to make the target position face the camera\n    if (positionProvided) {\n      this.cleanPosition(options);\n\n      // Longitude rotation along the vertical axis\n      var verticalAxis = new THREE.Vector3(0, 1, 0);\n      mesh.rotateOnWorldAxis(verticalAxis, options.longitude - this.prop.position.longitude);\n\n      // Latitude rotation along the camera horizontal axis\n      var horizontalAxis = new THREE.Vector3(0, 1, 0).cross(this.camera.getWorldDirection()).normalize();\n      mesh.rotateOnWorldAxis(horizontalAxis, options.latitude - this.prop.position.latitude);\n\n      // FIXME: find a better way to handle ranges\n      if (this.config.latitude_range || this.config.longitude_range) {\n        this.config.longitude_range = this.config.latitude_range = null;\n        console.warn('PhotoSphereViewer: trying to perform transition with longitude_range and/or latitude_range, ranges cleared.');\n      }\n    }\n\n    this.scene.add(mesh);\n    this.needsUpdate();\n\n    return new PSVAnimation({\n      properties: {\n        opacity: { start: 0.0, end: 1.0 },\n        zoom: zoomProvided ? { start: this.prop.zoom_lvl, end: options.zoom } : undefined\n      },\n      duration: this.config.transition.duration,\n      easing: 'outCubic',\n      onTick: function(properties) {\n        if (this.prop.isCubemap) {\n          for (var i = 0; i < 6; i++) {\n            mesh.material[i].opacity = properties.opacity;\n          }\n        }\n        else {\n          mesh.material.opacity = properties.opacity;\n        }\n\n        if (zoomProvided) {\n          this.zoom(properties.zoom);\n        }\n\n        this.needsUpdate();\n      }.bind(this)\n    })\n      .then(function() {\n        // remove temp sphere and transfer the texture to the main sphere\n        this._setTexture(texture);\n        this.scene.remove(mesh);\n\n        mesh.geometry.dispose();\n        mesh.geometry = null;\n\n        // actually rotate the camera\n        if (positionProvided) {\n          this.rotate(options);\n        }\n\n        if (options.sphere_correction) {\n          this._setSphereCorrection(this.mesh, options.sphere_correction);\n        }\n        else {\n          this._setSphereCorrection(this.mesh, {});\n        }\n      }.bind(this));\n      \n  };\n\n  /**\n   * @summary Reverses autorotate direction with smooth transition\n   * @private\n   */\n  PhotoSphereViewer.prototype._reverseAutorotate = function() {\n    var self = this;\n    var newSpeed = -this.config.anim_speed;\n    var range = this.config.longitude_range;\n    this.config.longitude_range = null;\n\n    new PSVAnimation({\n      properties: {\n        speed: { start: this.config.anim_speed, end: 0 }\n      },\n      duration: 300,\n      easing: 'inSine',\n      onTick: function(properties) {\n        self.config.anim_speed = properties.speed;\n      }\n    })\n      .then(function() {\n        return new PSVAnimation({\n          properties: {\n            speed: { start: 0, end: newSpeed }\n          },\n          duration: 300,\n          easing: 'outSine',\n          onTick: function(properties) {\n            self.config.anim_speed = properties.speed;\n          }\n        });\n      })\n      .then(function() {\n        self.config.longitude_range = range;\n        self.config.anim_speed = newSpeed;\n      });\n  };\n\n  /**\n   * @summary Adds a panorama to the cache\n   * @param {PhotoSphereViewer.CacheItem} cache\n   * @fires PhotoSphereViewer.panorama-cached\n   * @throws {PSVError} when the cache is disabled\n   * @private\n   */\n  PhotoSphereViewer.prototype._putPanoramaCache = function(cache) {\n    if (!this.config.cache_texture) {\n      throw new PSVError('Cannot add panorama to cache, cache_texture is disabled');\n    }\n\n    var existingCache = this.getPanoramaCache(cache.panorama);\n\n    if (existingCache) {\n      existingCache.image = cache.image;\n      existingCache.pano_data = cache.pano_data;\n    }\n    else {\n      this.prop.cache = this.prop.cache.slice(0, this.config.cache_texture - 1); // remove most ancient elements\n      this.prop.cache.unshift(cache);\n    }\n\n    /**\n     * @event panorama-cached\n     * @memberof PhotoSphereViewer\n     * @summary Triggered when a panorama is stored in the cache\n     * @param {string} panorama\n     */\n    this.trigger('panorama-cached', cache.panorama);\n  };\n\n  /**\n   * @summary Stops all current animations\n   * @private\n   */\n  PhotoSphereViewer.prototype._stopAll = function() {\n    this.stopAutorotate();\n    this.stopAnimation();\n    this.stopGyroscopeControl();\n    this.stopStereoView();\n  };\n\n  return PhotoSphereViewer;\n});"]}