{"version":3,"sources":["_psv/utils.js"],"names":["define","THREE","PhotoSphereViewer","PSVUtils","PSVError","_loadSystem","S","SYSTEM","loaded","pixelRatio","window","devicePixelRatio","isWebGLSupported","isCanvasSupported","maxTextureWidth","getMaxTextureWidth","mouseWheelEvent","fullscreenEvent","deviceOrientationSupported","isDeviceOrientationSupported","touchEnabled","isTouchEnabled","prototype","_setViewerSize","size","forEach","dim","test","this","parent","style","speedToDuration","value","angle","Math","abs","speed","parseSpeed","config","anim_speed","textureCoordsToSphericalCoords","point","prop","isCubemap","relativeX","x","pano_data","cropped_x","full_width","TwoPI","relativeY","y","cropped_y","full_height","PI","longitude","latitude","HalfPI","sphericalCoordsToTextureCoords","position","relativeLong","relativeLat","parseInt","sphericalCoordsToVector3","Vector3","SPHERE_RADIUS","cos","sin","vector3ToSphericalCoords","vector","phi","acos","sqrt","z","theta","atan2","viewerCoordsToVector3","viewerPoint","screen","Vector2","width","height","raycaster","setFromCamera","camera","intersects","intersectObjects","scene","children","length","vector3ToViewerCoords","clone","project","cleanPosition","hasOwnProperty","deepmerge","parseAngle","cleanSphereCorrection","sphere_correction","pan","tilt","roll","isExtendedPosition","object","some","keys","applyRanges","range","offset","sidesReached","longitude_range","degToRad","hFov","push","latitude_range","vFov","min","max"],"mappings":"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","file":"../../_psv/utils.js","sourcesContent":["define([\n  \"skylark-threejs\",\n  \"./ctoc\",\n  \"../PSVUtils\",\n  \"../PSVError\"\n],function(\n  THREE,\n  PhotoSphereViewer,\n  PSVUtils,\n  PSVError\n){\n  \"use strict\";\n  /**\n   * @summary Inits the global SYSTEM var with generic support information\n   * @private\n   */\n  PhotoSphereViewer._loadSystem = function() {\n    var S = PhotoSphereViewer.SYSTEM;\n    S.loaded = true;\n    S.pixelRatio = window.devicePixelRatio || 1;\n    S.isWebGLSupported = PSVUtils.isWebGLSupported();\n    S.isCanvasSupported = PSVUtils.isCanvasSupported();\n    S.maxTextureWidth = S.isWebGLSupported ? PSVUtils.getMaxTextureWidth() : 4096;\n    S.mouseWheelEvent = PSVUtils.mouseWheelEvent();\n    S.fullscreenEvent = PSVUtils.fullscreenEvent();\n    S.deviceOrientationSupported = PSVUtils.isDeviceOrientationSupported();\n    S.touchEnabled = PSVUtils.isTouchEnabled();\n  };\n\n  /**\n   * @summary Sets the viewer size\n   * @param {PhotoSphereViewer.Size} size\n   * @private\n   */\n  PhotoSphereViewer.prototype._setViewerSize = function(size) {\n    ['width', 'height'].forEach(function(dim) {\n      if (size[dim]) {\n        if (/^[0-9.]+$/.test(size[dim])) {\n          size[dim] += 'px';\n        }\n        this.parent.style[dim] = size[dim];\n      }\n    }, this);\n  };\n\n  /**\n   * @summary Converts a speed into a duration from current position to a new position\n   * @param {string|number} value\n   * @param {number} angle\n   * @returns {number}\n   */\n  PhotoSphereViewer.prototype.speedToDuration = function(value, angle) {\n    if (!value || typeof value !== 'number') {\n      // desired radial speed\n      var speed = value ? PSVUtils.parseSpeed(value) : this.config.anim_speed;\n      // compute duration\n      return angle / Math.abs(speed) * 1000;\n    }\n    else {\n      return Math.abs(value);\n    }\n  };\n\n  /**\n   * @summary Converts pixel texture coordinates to spherical radians coordinates\n   * @param {PhotoSphereViewer.Point} point\n   * @returns {PhotoSphereViewer.Position}\n   */\n  PhotoSphereViewer.prototype.textureCoordsToSphericalCoords = function(point) {\n    if (this.prop.isCubemap) {\n      throw new PSVError('Unable to use texture coords with cubemap.');\n    }\n\n    var relativeX = (point.x + this.prop.pano_data.cropped_x) / this.prop.pano_data.full_width * PSVUtils.TwoPI;\n    var relativeY = (point.y + this.prop.pano_data.cropped_y) / this.prop.pano_data.full_height * Math.PI;\n\n    return {\n      longitude: relativeX >= Math.PI ? relativeX - Math.PI : relativeX + Math.PI,\n      latitude: PSVUtils.HalfPI - relativeY\n    };\n  };\n\n  /**\n   * @summary Converts spherical radians coordinates to pixel texture coordinates\n   * @param {PhotoSphereViewer.Position} position\n   * @returns {PhotoSphereViewer.Point}\n   */\n  PhotoSphereViewer.prototype.sphericalCoordsToTextureCoords = function(position) {\n    if (this.prop.isCubemap) {\n      throw new PSVError('Unable to use texture coords with cubemap.');\n    }\n\n    var relativeLong = position.longitude / PSVUtils.TwoPI * this.prop.pano_data.full_width;\n    var relativeLat = position.latitude / Math.PI * this.prop.pano_data.full_height;\n\n    return {\n      x: parseInt(position.longitude < Math.PI ? relativeLong + this.prop.pano_data.full_width / 2 : relativeLong - this.prop.pano_data.full_width / 2) - this.prop.pano_data.cropped_x,\n      y: parseInt(this.prop.pano_data.full_height / 2 - relativeLat) - this.prop.pano_data.cropped_y\n    };\n  };\n\n  /**\n   * @summary Converts spherical radians coordinates to a THREE.Vector3\n   * @param {PhotoSphereViewer.Position} position\n   * @returns {THREE.Vector3}\n   */\n  PhotoSphereViewer.prototype.sphericalCoordsToVector3 = function(position) {\n    return new THREE.Vector3(\n      PhotoSphereViewer.SPHERE_RADIUS * -Math.cos(position.latitude) * Math.sin(position.longitude),\n      PhotoSphereViewer.SPHERE_RADIUS * Math.sin(position.latitude),\n      PhotoSphereViewer.SPHERE_RADIUS * Math.cos(position.latitude) * Math.cos(position.longitude)\n    );\n  };\n\n  /**\n   * @summary Converts a THREE.Vector3 to spherical radians coordinates\n   * @param {THREE.Vector3} vector\n   * @returns {PhotoSphereViewer.Position}\n   */\n  PhotoSphereViewer.prototype.vector3ToSphericalCoords = function(vector) {\n    var phi = Math.acos(vector.y / Math.sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z));\n    var theta = Math.atan2(vector.x, vector.z);\n\n    return {\n      longitude: theta < 0 ? -theta : PSVUtils.TwoPI - theta,\n      latitude: PSVUtils.HalfPI - phi\n    };\n  };\n\n  /**\n   * @summary Converts position on the viewer to a THREE.Vector3\n   * @param {PhotoSphereViewer.Point} viewerPoint\n   * @returns {THREE.Vector3}\n   */\n  PhotoSphereViewer.prototype.viewerCoordsToVector3 = function(viewerPoint) {\n    var screen = new THREE.Vector2(\n      2 * viewerPoint.x / this.prop.size.width - 1,\n      -2 * viewerPoint.y / this.prop.size.height + 1\n    );\n\n    this.raycaster.setFromCamera(screen, this.camera);\n\n    var intersects = this.raycaster.intersectObjects(this.scene.children);\n\n    if (intersects.length === 1) {\n      return intersects[0].point;\n    }\n    else {\n      return null;\n    }\n  };\n\n  /**\n   * @summary Converts a THREE.Vector3 to position on the viewer\n   * @param {THREE.Vector3} vector\n   * @returns {PhotoSphereViewer.Point}\n   */\n  PhotoSphereViewer.prototype.vector3ToViewerCoords = function(vector) {\n    vector = vector.clone();\n    vector.project(this.camera);\n\n    return {\n      x: parseInt((vector.x + 1) / 2 * this.prop.size.width),\n      y: parseInt((1 - vector.y) / 2 * this.prop.size.height)\n    };\n  };\n\n  /**\n   * @summary Converts x/y to latitude/longitude if present and ensure boundaries\n   * @param {PhotoSphereViewer.ExtendedPosition} position - mutated\n   * @private\n   */\n  PhotoSphereViewer.prototype.cleanPosition = function(position) {\n    if (position.hasOwnProperty('x') && position.hasOwnProperty('y')) {\n      PSVUtils.deepmerge(position, this.textureCoordsToSphericalCoords(position));\n    }\n\n    position.longitude = PSVUtils.parseAngle(position.longitude);\n    position.latitude = PSVUtils.parseAngle(position.latitude, true);\n  };\n\n  /**\n   * @summary Clean a SphereCorrection object\n   * @param {PhotoSphereViewer.SphereCorrection} sphere_correction - mutated\n   */\n  PhotoSphereViewer.prototype.cleanSphereCorrection = function(sphere_correction) {\n    sphere_correction.pan = PSVUtils.parseAngle(sphere_correction.pan || 0);\n    sphere_correction.tilt = PSVUtils.parseAngle(sphere_correction.tilt || 0, true);\n    sphere_correction.roll = PSVUtils.parseAngle(sphere_correction.roll || 0, true, false);\n  };\n\n  /**\n   * @summary Checks if an object is a {PhotoSphereViewer.ExtendedPosition}, ie has x/y or longitude/latitude\n   * @param {object} object\n   * @returns {boolean}\n   */\n  PhotoSphereViewer.prototype.isExtendedPosition = function(object) {\n    return [['x', 'y'], ['longitude', 'latitude']].some(function(keys) {\n      return keys[0] in object && keys[1] in object;\n    });\n  };\n\n  /**\n   * @summary Apply \"longitude_range\" and \"latitude_range\"\n   * @param {PhotoSphereViewer.Position} position - mutated\n   * @returns {string[]} list of sides that were reached\n   * @private\n   */\n  PhotoSphereViewer.prototype.applyRanges = function(position) {\n    var range, offset, sidesReached = [];\n\n    if (this.config.longitude_range) {\n      range = PSVUtils.clone(this.config.longitude_range);\n      offset = THREE.Math.degToRad(this.prop.hFov) / 2;\n\n      range[0] = PSVUtils.parseAngle(range[0] + offset);\n      range[1] = PSVUtils.parseAngle(range[1] - offset);\n\n      if (range[0] > range[1]) { // when the range cross longitude 0\n        if (position.longitude > range[1] && position.longitude < range[0]) {\n          if (position.longitude > (range[0] / 2 + range[1] / 2)) { // detect which side we are closer too\n            position.longitude = range[0];\n            sidesReached.push('left');\n          }\n          else {\n            position.longitude = range[1];\n            sidesReached.push('right');\n          }\n        }\n      }\n      else {\n        if (position.longitude < range[0]) {\n          position.longitude = range[0];\n          sidesReached.push('left');\n        }\n        else if (position.longitude > range[1]) {\n          position.longitude = range[1];\n          sidesReached.push('right');\n        }\n      }\n    }\n\n    if (this.config.latitude_range) {\n      range = PSVUtils.clone(this.config.latitude_range);\n      offset = THREE.Math.degToRad(this.prop.vFov) / 2;\n\n      range[0] = PSVUtils.parseAngle(Math.min(range[0] + offset, range[1]), true);\n      range[1] = PSVUtils.parseAngle(Math.max(range[1] - offset, range[0]), true);\n\n      if (position.latitude < range[0]) {\n        position.latitude = range[0];\n        sidesReached.push('bottom');\n      }\n      else if (position.latitude > range[1]) {\n        position.latitude = range[1];\n        sidesReached.push('top');\n      }\n    }\n\n    return sidesReached;\n  };\n\n  return PhotoSphereViewer;\n});"]}