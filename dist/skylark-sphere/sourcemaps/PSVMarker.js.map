{"version":3,"sources":["PSVMarker.js"],"names":["define","PSVError","PSVAnimation","PSVUtils","PSVMarker","properties","psv","id","image","width","height","html","hasOwnProperty","this","visible","_dynamicSize","$el","_id","_type","getType","Object","defineProperties","configurable","enumerable","get","set","type","_def","value","isNormal","document","createElement","isPolygon","createElementNS","svgNS","isPolyline","psvMarker","update","types","allowNone","found","forEach","push","length","join","prototype","destroy","isPoly","isSvg","getScale","zoomLevel","Array","isArray","scale","easings","inQuad","newType","undefined","deepmerge","setAttribute","className","addClasses","tooltip","content","style","anchor","parsePosition","_updateNormal","_updatePoly","_updateSvg","backgroundImage","innerHTML","transformOrigin","left","top","cleanPosition","position3D","sphericalCoordsToVector3","x","y","cx","cy","r","rx","ry","d","getOwnPropertyNames","prop","setAttributeNS","svgStyle","dasherize","key_rad","key_px","fill","polygon","i","splice","map","coord","sphericalCoords","textureCoordsToSphericalCoords","longitude","latitude","parseAngle","positions3D"],"mappings":"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","file":"../PSVMarker.js","sourcesContent":["define([\n  \"./PSVError\",\n  \"./PSVAnimation\",\n  \"./PSVUtils\"\n],function(\n  PSVError,\n  PSVAnimation,\n  PSVUtils\n){\n  \"use strict\";\n  /**\n   * Object representing a marker\n   * @param {Object} properties - see {@link http://photo-sphere-viewer.js.org/markers.html#config} (merged with the object itself)\n   * @param {PhotoSphereViewer} psv\n   * @constructor\n   * @throws {PSVError} when the configuration is incorrect\n   */\n  function PSVMarker(properties, psv) {\n    if (!properties.id) {\n      throw new PSVError('missing marker id');\n    }\n\n    if (properties.image && (!properties.width || !properties.height)) {\n      throw new PSVError('missing marker width/height');\n    }\n\n    if (properties.image || properties.html) {\n      if ((!properties.hasOwnProperty('x') || !properties.hasOwnProperty('y')) && (!properties.hasOwnProperty('latitude') || !properties.hasOwnProperty('longitude'))) {\n        throw new PSVError('missing marker position, latitude/longitude or x/y');\n      }\n    }\n\n    /**\n     * @member {PhotoSphereViewer}\n     * @readonly\n     * @protected\n     */\n    this.psv = psv;\n\n    /**\n     * @member {boolean}\n     */\n    this.visible = true;\n\n    /**\n     * @member {boolean}\n     * @readonly\n     * @private\n     */\n    this._dynamicSize = false;\n\n    // private properties\n    var _id = properties.id;\n    var _type = PSVMarker.getType(properties, false);\n    var $el;\n\n    // readonly properties\n    Object.defineProperties(this, {\n      /**\n       * @memberof PSVMarker\n       * @type {string}\n       * @readonly\n       */\n      id: {\n        configurable: false,\n        enumerable: true,\n        get: function() {\n          return _id;\n        },\n        set: function() {\n        }\n      },\n      /**\n       * @memberof PSVMarker\n       * @type {string}\n       * @see PSVMarker.types\n       * @readonly\n       */\n      type: {\n        configurable: false,\n        enumerable: true,\n        get: function() {\n          return _type;\n        },\n        set: function() {\n        }\n      },\n      /**\n       * @memberof PSVMarker\n       * @type {HTMLDivElement|SVGElement}\n       * @readonly\n       */\n      $el: {\n        configurable: false,\n        enumerable: true,\n        get: function() {\n          return $el;\n        },\n        set: function() {\n        }\n      },\n      /**\n       * @summary Quick access to self value of key `type`\n       * @memberof PSVMarker\n       * @type {*}\n       * @private\n       */\n      _def: {\n        configurable: false,\n        enumerable: true,\n        get: function() {\n          return this[_type];\n        },\n        set: function(value) {\n          this[_type] = value;\n        }\n      }\n    });\n\n    // create element\n    if (this.isNormal()) {\n      $el = document.createElement('div');\n    }\n    else if (this.isPolygon()) {\n      $el = document.createElementNS(PSVUtils.svgNS, 'polygon');\n    }\n    else if (this.isPolyline()) {\n      $el = document.createElementNS(PSVUtils.svgNS, 'polyline');\n    }\n    else {\n      $el = document.createElementNS(PSVUtils.svgNS, this.type);\n    }\n\n    $el.id = 'psv-marker-' + this.id;\n    $el.psvMarker = this;\n\n    this.update(properties);\n  }\n\n  /**\n   * @summary Types of markers\n   * @type {string[]}\n   * @readonly\n   */\n  PSVMarker.types = ['image', 'html', 'polygon_px', 'polygon_rad', 'polyline_px', 'polyline_rad', 'rect', 'circle', 'ellipse', 'path'];\n\n  /**\n   * @summary Determines the type of a marker by the available properties\n   * @param {object} properties\n   * @param {boolean} [allowNone=false]\n   * @returns {string}\n   * @throws {PSVError} when the marker's type cannot be found\n   */\n  PSVMarker.getType = function(properties, allowNone) {\n    var found = [];\n\n    PSVMarker.types.forEach(function(type) {\n      if (properties[type]) {\n        found.push(type);\n      }\n    });\n\n    if (found.length === 0 && !allowNone) {\n      throw new PSVError('missing marker content, either ' + PSVMarker.types.join(', '));\n    }\n    else if (found.length > 1) {\n      throw new PSVError('multiple marker content, either ' + PSVMarker.types.join(', '));\n    }\n\n    return found[0];\n  };\n\n  /**\n   * @summary Destroys the marker\n   */\n  PSVMarker.prototype.destroy = function() {\n    delete this.$el.psvMarker;\n  };\n\n  /**\n   * @summary Checks if it is a normal marker (image or html)\n   * @returns {boolean}\n   */\n  PSVMarker.prototype.isNormal = function() {\n    return this.type === 'image' || this.type === 'html';\n  };\n\n  /**\n   * @summary Checks if it is a polygon/polyline marker\n   * @returns {boolean}\n   */\n  PSVMarker.prototype.isPoly = function() {\n    return this.isPolygon() || this.isPolyline();\n  };\n\n  /**\n   * @summary Checks if it is a polygon marker\n   * @returns {boolean}\n   */\n  PSVMarker.prototype.isPolygon = function() {\n    return this.type === 'polygon_px' || this.type === 'polygon_rad';\n  };\n\n  /**\n   * @summary Checks if it is a polyline marker\n   * @returns {boolean}\n   */\n  PSVMarker.prototype.isPolyline = function() {\n    return this.type === 'polyline_px' || this.type === 'polyline_rad';\n  };\n\n  /**\n   * @summary Checks if it is an SVG marker\n   * @returns {boolean}\n   */\n  PSVMarker.prototype.isSvg = function() {\n    return this.type === 'rect' || this.type === 'circle' || this.type === 'ellipse' || this.type === 'path';\n  };\n\n  /**\n   * @summary Computes marker scale from zoom level\n   * @param {float} zoomLevel\n   * @returns {float}\n   */\n  PSVMarker.prototype.getScale = function(zoomLevel) {\n    if (Array.isArray(this.scale)) {\n      return this.scale[0] + (this.scale[1] - this.scale[0]) * PSVAnimation.easings.inQuad(zoomLevel / 100);\n    }\n    else if (typeof this.scale === 'function') {\n      return this.scale(zoomLevel);\n    }\n    else if (typeof this.scale === 'number') {\n      return this.scale * PSVAnimation.easings.inQuad(zoomLevel / 100);\n    }\n    else {\n      return 1;\n    }\n  };\n\n  /**\n   * @summary Updates the marker with new properties\n   * @param {object} [properties]\n   * @throws {PSVError} when trying to change the marker's type\n   */\n  PSVMarker.prototype.update = function(properties) {\n    // merge objects\n    if (properties && properties !== this) {\n      var newType = PSVMarker.getType(properties, true);\n\n      if (newType !== undefined && newType !== this.type) {\n        throw new PSVError('cannot change marker type');\n      }\n\n      PSVUtils.deepmerge(this, properties);\n    }\n\n    // reset CSS class\n    if (this.isNormal()) {\n      this.$el.setAttribute('class', 'psv-marker psv-marker--normal');\n    }\n    else {\n      this.$el.setAttribute('class', 'psv-marker psv-marker--svg');\n    }\n\n    // add CSS classes\n    if (this.className) {\n      PSVUtils.addClasses(this.$el, this.className);\n    }\n    if (this.tooltip) {\n      PSVUtils.addClasses(this.$el, 'has-tooltip');\n      if (typeof this.tooltip === 'string') {\n        this.tooltip = { content: this.tooltip };\n      }\n    }\n\n    // apply style\n    if (this.style) {\n      PSVUtils.deepmerge(this.$el.style, this.style);\n    }\n\n    // parse anchor\n    this.anchor = PSVUtils.parsePosition(this.anchor);\n\n    if (this.isNormal()) {\n      this._updateNormal();\n    }\n    else if (this.isPolygon()) {\n      this._updatePoly('polygon_rad', 'polygon_px');\n    }\n    else if (this.isPolyline()) {\n      this._updatePoly('polyline_rad', 'polyline_px');\n    }\n    else {\n      this._updateSvg();\n    }\n  };\n\n  /**\n   * @summary Updates a normal marker\n   * @private\n   */\n  PSVMarker.prototype._updateNormal = function() {\n    if (this.width && this.height) {\n      this.$el.style.width = this.width + 'px';\n      this.$el.style.height = this.height + 'px';\n      this._dynamicSize = false;\n    }\n    else {\n      this._dynamicSize = true;\n    }\n\n    if (this.image) {\n      this.$el.style.backgroundImage = 'url(' + this.image + ')';\n    }\n    else {\n      this.$el.innerHTML = this.html;\n    }\n\n    // set anchor\n    this.$el.style.transformOrigin = this.anchor.left * 100 + '% ' + this.anchor.top * 100 + '%';\n\n    // convert texture coordinates to spherical coordinates\n    this.psv.cleanPosition(this);\n\n    // compute x/y/z position\n    this.position3D = this.psv.sphericalCoordsToVector3(this);\n  };\n\n  /**\n   * @summary Updates an SVG marker\n   * @private\n   */\n  PSVMarker.prototype._updateSvg = function() {\n    this._dynamicSize = true;\n\n    // set content\n    switch (this.type) {\n      case 'rect':\n        if (typeof this._def === 'number') {\n          this._def = {\n            x: 0,\n            y: 0,\n            width: this._def,\n            height: this._def\n          };\n        }\n        else if (Array.isArray(this._def)) {\n          this._def = {\n            x: 0,\n            y: 0,\n            width: this._def[0],\n            height: this._def[1]\n          };\n        }\n        else {\n          this._def.x = this._def.y = 0;\n        }\n        break;\n\n      case 'circle':\n        if (typeof this._def === 'number') {\n          this._def = {\n            cx: this._def,\n            cy: this._def,\n            r: this._def\n          };\n        }\n        else if (Array.isArray(this._def)) {\n          this._def = {\n            cx: this._def[0],\n            cy: this._def[0],\n            r: this._def[0]\n          };\n        }\n        else {\n          this._def.cx = this._def.cy = this._def.r;\n        }\n        break;\n\n      case 'ellipse':\n        if (typeof this._def === 'number') {\n          this._def = {\n            cx: this._def,\n            cy: this._def,\n            rx: this._def,\n            ry: this._def\n          };\n        }\n        else if (Array.isArray(this._def)) {\n          this._def = {\n            cx: this._def[0],\n            cy: this._def[1],\n            rx: this._def[0],\n            ry: this._def[1]\n          };\n        }\n        else {\n          this._def.cx = this._def.rx;\n          this._def.cy = this._def.ry;\n        }\n        break;\n\n      case 'path':\n        if (typeof this._def === 'string') {\n          this._def = {\n            d: this._def\n          };\n        }\n        break;\n    }\n\n    Object.getOwnPropertyNames(this._def).forEach(function(prop) {\n      this.$el.setAttributeNS(null, prop, this._def[prop]);\n    }, this);\n\n    // set style\n    if (this.svgStyle) {\n      Object.getOwnPropertyNames(this.svgStyle).forEach(function(prop) {\n        this.$el.setAttributeNS(null, PSVUtils.dasherize(prop), this.svgStyle[prop]);\n      }, this);\n    }\n    else {\n      this.$el.setAttributeNS(null, 'fill', 'rgba(0,0,0,0.5)');\n    }\n\n    // convert texture coordinates to spherical coordinates\n    this.psv.cleanPosition(this);\n\n    // compute x/y/z position\n    this.position3D = this.psv.sphericalCoordsToVector3(this);\n  };\n\n  /**\n   * @summary Updates a polygon marker\n   * @param {'polygon_rad'|'polyline_rad'} key_rad\n   * @param {'polygon_px'|'polyline_px'} key_px\n   * @private\n   */\n  PSVMarker.prototype._updatePoly = function(key_rad, key_px) {\n    this._dynamicSize = true;\n\n    // set style\n    if (this.svgStyle) {\n      Object.getOwnPropertyNames(this.svgStyle).forEach(function(prop) {\n        this.$el.setAttributeNS(null, PSVUtils.dasherize(prop), this.svgStyle[prop]);\n      }, this);\n\n      if (this.isPolyline() && !this.svgStyle.fill) {\n        this.$el.setAttributeNS(null, 'fill', 'none');\n      }\n    }\n    else if (this.isPolygon()) {\n      this.$el.setAttributeNS(null, 'fill', 'rgba(0,0,0,0.5)');\n    }\n    else if (this.isPolyline()) {\n      this.$el.setAttributeNS(null, 'fill', 'none');\n      this.$el.setAttributeNS(null, 'stroke', 'rgb(0,0,0)');\n    }\n\n    // fold arrays: [1,2,3,4] => [[1,2],[3,4]]\n    [this[key_rad], this[key_px]].forEach(function(polygon) {\n      if (polygon && typeof polygon[0] !== 'object') {\n        for (var i = 0; i < polygon.length; i++) {\n          polygon.splice(i, 2, [polygon[i], polygon[i + 1]]);\n        }\n      }\n    });\n\n    // convert texture coordinates to spherical coordinates\n    if (this[key_px]) {\n      this[key_rad] = this[key_px].map(function(coord) {\n        var sphericalCoords = this.psv.textureCoordsToSphericalCoords({ x: coord[0], y: coord[1] });\n        return [sphericalCoords.longitude, sphericalCoords.latitude];\n      }, this);\n    }\n    // clean angles\n    else {\n      this[key_rad] = this[key_rad].map(function(coord) {\n        return [\n          PSVUtils.parseAngle(coord[0]),\n          PSVUtils.parseAngle(coord[1], true)\n        ];\n      });\n    }\n\n    // TODO : compute the center of the polygon\n    this.longitude = this[key_rad][0][0];\n    this.latitude = this[key_rad][0][1];\n\n    // compute x/y/z positions\n    this.positions3D = this[key_rad].map(function(coord) {\n      return this.psv.sphericalCoordsToVector3({ longitude: coord[0], latitude: coord[1] });\n    }, this);\n  };\n\n  return PSVMarker;\n});"]}